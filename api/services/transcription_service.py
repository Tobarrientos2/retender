"""
Servicio de transcripci√≥n usando OpenAI Whisper
"""

import os
import time
import asyncio
from typing import Optional, Dict, Any, Callable
from pathlib import Path

from loguru import logger

from models.transcription_models import (
    TranscriptionRequest,
    TranscriptionResponse,
    TranscriptionSegment,
    AudioInfo
)
from services.groq_transcription_service import groq_transcription_service


class TranscriptionService:
    """Servicio de transcripci√≥n de audio usando Whisper"""
    
    def __init__(self):
        self.models: Dict[str, Any] = {}
        self.current_model_name: Optional[str] = None
        # Config flags
        self.use_faster_whisper = True  # Local CPU/GPU inference
        self.use_openai_api = False  # Usar solo modelo local
        
    async def initialize(self):
        """Inicializar el servicio de transcripci√≥n"""
        logger.info("üîÑ Inicializando servicio de transcripci√≥n...")

        # Inicializar Groq Cloud API (Whisper Large-v3 Turbo)
        await groq_transcription_service.initialize()

        logger.info("‚úÖ Servicio de transcripci√≥n inicializado")
    
    async def load_model(self, model_name: str = "base") -> bool:
        """
        Cargar modelo Whisper
        
        Args:
            model_name: Nombre del modelo (tiny, base, small, medium, large)
            
        Returns:
            bool: True si se carg√≥ correctamente
        """
        # Si usamos la API de OpenAI no cargamos modelos locales
        if self.use_openai_api:
            logger.info("üîó Configurado para usar OpenAI Whisper API ‚Äì no se cargan modelos locales")
            return True
        
        try:
            if model_name in self.models:
                logger.info(f"üì¶ Modelo {model_name} ya est√° cargado")
                return True
            
            logger.info(f"üì• Cargando modelo Whisper: {model_name}")
            start_time = time.time()
            
            # Con Groq Cloud no necesitamos cargar modelos localmente
            logger.info(f"üì¶ Modelo Groq Cloud configurado: {model_name}")
            # Simular modelo cargado para compatibilidad
            self.models[model_name] = "groq_cloud_model"
            self.current_model_name = model_name
            
            load_time = time.time() - start_time
            logger.info(f"‚úÖ Modelo {model_name} cargado en {load_time:.2f}s")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error cargando modelo {model_name}: {e}")
            return False
    
    async def transcribe(self, request: TranscriptionRequest) -> TranscriptionResponse:
        """
        Transcribir archivo de audio usando Groq Cloud API

        Args:
            request: Request de transcripci√≥n

        Returns:
            TranscriptionResponse: Resultado de la transcripci√≥n
        """
        logger.info(f"üé§ Iniciando transcripci√≥n con Groq Cloud - Archivo: {Path(request.audio_file_path).name}")

        try:
            # Usar Groq Cloud API para transcripci√≥n
            response = await groq_transcription_service.transcribe_audio(request)

            logger.info(f"‚úÖ Transcripci√≥n completada en {response.processing_time:.2f}s")
            return response

        except Exception as e:
            logger.error(f"‚ùå Error en transcripci√≥n: {e}")
            raise Exception(f"Error en transcripci√≥n: {str(e)}")
    
    async def _transcribe_faster_whisper(self, model: Any, request: TranscriptionRequest) -> Dict[str, Any]:
        """Transcribir usando faster-whisper"""
        
        # Configurar par√°metros
        transcribe_params = {
            "language": request.language,
            "temperature": request.temperature,
            "initial_prompt": request.initial_prompt,
        }
        
        # Remover par√°metros None
        transcribe_params = {k: v for k, v in transcribe_params.items() if v is not None}
        
        # Transcribir
        segments, info = model.transcribe(
            request.audio_file_path,
            **transcribe_params
        )
        
        # Procesar resultados
        text_segments = []
        full_text = ""
        
        for i, segment in enumerate(segments):
            segment_data = TranscriptionSegment(
                id=i,
                start=segment.start,
                end=segment.end,
                text=segment.text.strip(),
                confidence=getattr(segment, 'avg_logprob', None)
            )
            text_segments.append(segment_data)
            full_text += segment.text.strip() + " "
        
        return {
            "text": full_text.strip(),
            "language": info.language,
            "segments": text_segments if request.return_timestamps else []
        }
    

    
    async def _get_audio_info(self, file_path: str) -> AudioInfo:
        """Obtener informaci√≥n del archivo de audio"""
        try:
            import ffmpeg
            
            # Obtener informaci√≥n usando ffprobe
            probe = ffmpeg.probe(file_path)
            audio_stream = next(
                (stream for stream in probe['streams'] if stream['codec_type'] == 'audio'),
                None
            )
            
            if not audio_stream:
                raise Exception("No se encontr√≥ stream de audio")
            
            duration = float(audio_stream.get('duration', 0))
            sample_rate = int(audio_stream.get('sample_rate', 0))
            channels = int(audio_stream.get('channels', 1))
            
            # Obtener tama√±o del archivo
            file_size = os.path.getsize(file_path)
            size_mb = file_size / (1024 * 1024)
            
            # Obtener formato
            format_name = probe['format']['format_name']
            
            return AudioInfo(
                duration=duration,
                sample_rate=sample_rate,
                channels=channels,
                format=format_name,
                size_mb=round(size_mb, 2)
            )
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo obtener info de audio: {e}")
            # Fallback con informaci√≥n b√°sica
            file_size = os.path.getsize(file_path)
            return AudioInfo(
                duration=0.0,
                sample_rate=16000,
                channels=1,
                format="unknown",
                size_mb=round(file_size / (1024 * 1024), 2)
            )
    
    async def health_check(self) -> bool:
        """Verificar que el servicio est√© funcionando"""
        try:
            # Verificar que el servicio Groq est√© healthy
            is_groq_healthy = await groq_transcription_service.health_check()

            if not is_groq_healthy:
                logger.warning("‚ö†Ô∏è Servicio Groq no est√° healthy")
                return False

            logger.info("‚úÖ Servicio de transcripci√≥n healthy")
            return True

        except Exception as e:
            logger.error(f"‚ùå Health check fall√≥: {e}")
            return False
    
    async def transcribe_with_progress(
        self,
        request: TranscriptionRequest,
        progress_callback: Optional[Callable] = None
    ) -> TranscriptionResponse:
        """
        Transcribir audio con callbacks de progreso usando Groq Cloud
        """
        try:
            # Usar Groq Cloud API con progreso
            response = await groq_transcription_service.transcribe_with_progress(
                request, progress_callback
            )

            logger.info(f"‚úÖ Transcripci√≥n con progreso completada en {response.processing_time:.2f}s")
            return response

        except Exception as e:
            if progress_callback:
                await progress_callback(-1.0, f"Error: {str(e)}")
            logger.error(f"‚ùå Error en transcripci√≥n con progreso: {e}")
            raise Exception(f"Error en transcripci√≥n: {str(e)}")

    async def _transcribe_faster_whisper_with_progress(
        self,
        model: Any,
        request: TranscriptionRequest,
        progress_callback: Optional[Callable] = None
    ) -> Dict[str, Any]:
        """Transcribir usando faster-whisper con callbacks de progreso"""

        # Configurar par√°metros
        transcribe_params = {
            "language": request.language,
            "temperature": request.temperature,
            "initial_prompt": request.initial_prompt,
        }

        # Remover par√°metros None
        transcribe_params = {k: v for k, v in transcribe_params.items() if v is not None}

        if progress_callback:
            await progress_callback(40.0, "Iniciando transcripci√≥n del modelo...")

        # Transcribir (faster-whisper no tiene callbacks nativos, simulamos progreso)
        segments, info = model.transcribe(
            request.audio_file_path,
            **transcribe_params
        )

        # Procesar resultados con progreso simulado
        text_segments = []
        full_text = ""

        # Convertir generator a lista para poder calcular progreso
        segments_list = list(segments)
        total_segments = len(segments_list)

        for i, segment in enumerate(segments_list):
            # Calcular progreso (40% - 80%)
            segment_progress = 40.0 + ((i + 1) / total_segments) * 40.0

            if progress_callback and i % 5 == 0:  # Actualizar cada 5 segmentos
                await progress_callback(
                    segment_progress,
                    f"Procesando segmento {i + 1}/{total_segments}"
                )

            segment_data = TranscriptionSegment(
                id=i,
                start=segment.start,
                end=segment.end,
                text=segment.text.strip(),
                confidence=getattr(segment, 'avg_logprob', None)
            )
            text_segments.append(segment_data)
            full_text += segment.text.strip() + " "

        if progress_callback:
            await progress_callback(80.0, "Transcripci√≥n del modelo completada")

        return {
            "text": full_text.strip(),
            "language": info.language,
            "segments": text_segments if request.return_timestamps else []
        }

    async def cleanup(self):
        """Limpiar recursos"""
        logger.info("üîÑ Limpiando recursos del servicio de transcripci√≥n")

        # Limpiar modelos cargados
        self.models.clear()
        self.current_model_name = None

        logger.info("‚úÖ Recursos limpiados")
    
    def get_loaded_models(self) -> list:
        """Obtener lista de modelos cargados"""
        return list(self.models.keys())
    
    def get_current_model(self) -> Optional[str]:
        """Obtener modelo actual"""
        return self.current_model_name
